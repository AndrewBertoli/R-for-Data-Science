---
title: "day_four"
author: "Dillon Niederhut"
date: "July 27, 2015"
output: pdf_document
---

## Introduction

Remember how we said that R started off as a functional language? This means that, underneath the hood, R is built on many small functions that can be grouped together in smart ways to do powerful things. It also means that, if you want to do more complicated things in R than run summary statistics and linear models, you'll need to learn how to create and use functions.

In R, functions are first-class citizens. This means that you can do anything to a function that you can do to an object, including using functions to create other functions.

> side note - while you can use loops in R, the community strongly discourages explicit looping in favor of implicit loop functionals like `Map` and `lapply`

Structuring a computer language around functions and their methods makes it easily parellelizable in ways that object oriented languages are usually not (for many complicated reasons that we don't have time to talk about). Key components of function-oriented languages are functions that write functions and the ability to map functions to data structures.

Finally, when we talk about the amazing extensibility of R, what we mean is that other people have written useful functions that you can find and download. If R is required in your field, it is likely because there are many functions specific to your field that have been developed in R. We'll close the intensive with a brief introduction to packaging and sharing R functions.

# Functions

## it's really easy to create functions in R

```{r}
f <- function(x) x + 1
class(f)
```

## every function has three parts

every function needs inputs - these are called `arguments` (or, here, formal arguments)

every function has stuff it does, and this stuff is contained in the body

every function has an `environment` that it executes in

```{r}
formals(f)
body(f)
environment(f)
```

## environments are where the function was defined

see how our function has `R_GlobalEnv` as it's environment? that's because we defined it in the global environment

this means that if you tell a function to look for an `object`, it will look in the global namespace

```{r}
f <- function(x) x + y
y <- 1
f(x = 1)
```

## it's very common for functions to be declared within another function

```{r}
y <- 9001
f <- function(x) {
  y <- 1
  g <- function (x) {
    x + y
  }
  g(x)
}
f(1)
```

this is important because it means that functions can be separated from the state of your computer (which is what makes them easy to parallelize)

## functions don't modify your computer state (usually)

an obvious exception is writing/reading from disk, but what we really mean here is that anything created inside the function environment doesn't show up in the global environment

```{r}
h <- function(){
  if (!exists('a')) {
    a <- 1
  }
  else {
    a <- a + 9000
  }
  print(a)
}
h()
h()
```

there are ways to make functions modify global variables, but this is generally not a good idea - anything that needs to go into a function should be in the arguments, and anything that needs to come out of the function should be returned

> side note - R automatically returns the value of the last expression, so there is no need for an explicit `return` statement unless you want to break the function early

a couple of days ago, we were dealing with data that came in several different units of length - let's try writing a function that converts inches to centimeters

```{r}
in_to_cm <- function(x) x * 2.5
in_to_cm(69)
```

that's not juvenile humor - it's actually Dillon's height in inches

what if we want to know how tall we are in meters?

you could do `function(x) x * 2.5 / 100 ` but this would be repeating yourself

then, when you figure out that the conversion factor is really *2.54*, not 2.5, you might update one and forget to update the other

```{r}
in_to_m <- function(x){
  in_to_cm(x) / 100
}
in_to_m(69)
```

now, if we go back and update `in_to_cm`, those changes automatically get propogated to `in_to_m`

```{r}
in_to_cm <- function(x) x * 2.54
in_to_m(69)
```

if you were here for the intro to Unix, this idea of small functions combined together should sound awfully familiar

R is a bit quirky in that there is no such thing as an uncontained value, e.g. `4` is really a vector with length of one, and a value of 4 in position 1

```{r}
69 == c(69)
```

this means that R automatically broadcasts functions across vectors of any length

```{r}
heights <- c(69,54,73,82)
in_to_m(heights)
```

## this doesn't work with lists

```{r, eval=FALSE}
heights <- list(69,54,73,82)
in_to_m(heights)
```

# Functionals

a functional is a function that takes functions as arguments

## the wrong way to be functional

imagine you want to apply a function to the columns of a dataframe (which is a list!)

you could do something like this:

```{r}
in_to_m(heights[[1]])
in_to_m(heights[[2]])
in_to_m(heights[[3]])
```

but this is clunky, prone to errors, and can't acommodate changes in your list - if you added another item in the list, you would need to find every place you tried to do this and `cntrl-c` `cntrl-v` a whole bunch of crap

## the right way to be functional

```{r}
lapply(heights, in_to_m)
```
## it's not always smart to name functions

these are called anonymous functions - they aren't actually any different, but you should know they exist

```{r}
lapply(heights, FUN = function(x) x %/% 12)
```

## lapply has limits

```{r}
dat <- read.csv('data/large.csv')
str(dat)
lapply(dat, mean)
```

we *know* there are numbers there - why are the means all missing?

a. we didn't use amelia
b. `mean` has an argument named `na.rm` that ignores missingness

*and for Hadley knows what reason, the default is FALSE*

but we can't do this

```{r, eval=FALSE}
lapply(dat, mean(na.rm = TRUE))
```

## so we use Map

Map is a function similar to those found in other functional languages

```{r, eval=FALSE}
Map(mean, dat, na.rm=TRUE)
```

## this can be parallelized

```{r}
install.packages('parallel')
library(parallel)
system.time(Map(median, dat, na.rm=TRUE))
system.time(mcMap(median, dat, na.rm=TRUE))
```

so that's not any better, but this is a small dataset

## Map can be combined with other Filter and Reduce

this is a quick, powerful, and parallelizable way to handle data

```{r}

```

# Packages

** Real artists ship - Steve Jobs **

# Acknowledgements

## Materials taken from:

[Software Carpentry](https://swcarpentry.github.io/)
[Hadley Wickham](http://adv-r.had.co.nz/)
